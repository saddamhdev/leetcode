Here is the **simplest, beginner-friendly explanation** of
‚≠ê **Sliding Window (Two Pointers Expanding/Contracting)**
with diagrams + when to use + example problems.

---

# ‚úÖ What Is Sliding Window?

Sliding window is a technique where you use **two pointers** (usually `left` and `right`) to keep track of a *moving window* inside an array or string.

The window can:

* **Expand** (right pointer moves)
* **Shrink** (left pointer moves)

You use it when you want to find **something in a continuous subarray/substring**.

---

# üß† Why Use Sliding Window?

Without sliding window:
‚Üí You check all possible subarrays ‚Üí O(n¬≤) time.

With sliding window:
‚Üí You maintain only the necessary window ‚Üí O(n) time.

---

# üéØ When To Use Sliding Window?

Use sliding window when the problem says words like:

* "Longest substring"
* "Smallest subarray"
* "Subarray with sum <= target"
* "First window of size k"
* "Count subarrays satisfying ‚Ä¶"
* "Substring without repeating characters"
* "Max vowels in window size k"

---

# ‚≠ê Two Main Types of Sliding Window

---

# 1Ô∏è‚É£ **Fixed Size Window**

Window size is constant (`k`).

### Example

**Max sum of a subarray of size k**

```
[2, 5, 1, 8, 2, 9]
k = 3

Windows:
[2 5 1] sum=8
[5 1 8] sum=14
[1 8 2] sum=11
[8 2 9] sum=19 ‚Üê answer
```

### Code

```java
int maxSum(int[] arr, int k) {
    int sum = 0;
    int max = 0;

    // build first window
    for (int i = 0; i < k; i++)
        sum += arr[i];

    max = sum;

    // slide the window
    for (int right = k; right < arr.length; right++) {
        sum += arr[right];       // add new element
        sum -= arr[right - k];   // remove old element
        max = Math.max(max, sum);
    }

    return max;
}
```

---

# 2Ô∏è‚É£ **Variable Size Window**

Window grows and shrinks based on some condition.

### Example (VERY IMPORTANT)

**Longest substring without repeating characters**
(LeetCode 3)

Goal: longest window with **unique characters**.

---

### Step-by-step Example: `"abcabcbb"`

```
Expand right ‚Üí
When duplicate found ‚Üí shrink left ‚Üí
```

Window moves like this:

```
a
ab
abc
abc a ‚Üí duplicate 'a' ‚áí shrink left
bc a
bca b ‚Üí duplicate 'b' ‚áí shrink
ca b
cab c ‚Üí duplicate 'c' ‚áí shrink
ab c
abc b -> duplicate
```

Longest = `"abc"` ‚Üí length 3

---

### Code (most famous sliding window template)

```java
public int lengthOfLongestSubstring(String s) {
    int left = 0;
    int maxLen = 0;
    HashSet<Character> set = new HashSet<>();

    for (int right = 0; right < s.length(); right++) {
        while (set.contains(s.charAt(right))) {
            set.remove(s.charAt(left));
            left++;
        }
        set.add(s.charAt(right));
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
```

---

# üî• Sliding Window Template (Variable Window)

Use this for 80% of problems:

```java
int left = 0;
for (right = 0; right < n; right++) {

    // 1. expand window (add arr[right])

    while (window is invalid) {
        // 2. shrink window (remove arr[left])
        left++;
    }

    // 3. update result (window is valid)
}
```

---

# üéØ Another Classic Example

**Smallest subarray with sum ‚â• target**

```
[2, 3, 1, 2, 4, 3]
target = 7
```

Windows:

```
[2, 3, 1, 2] sum = 8 ‚Üí shrink ‚Üí [1,2] sum=3 invalid
smallest = 4

[3,1,2,4] sum=10 ‚Üí shrink ‚Üí [4] sum=4 ‚Üí invalid
...
Result = 2 (subarray [4,3])
```

---

### Code

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0, sum = 0, min = Integer.MAX_VALUE;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];

        while (sum >= target) {
            min = Math.min(min, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }

    return min == Integer.MAX_VALUE ? 0 : min;
}
```

---

# üéÅ Summary Cheatsheet

| Type                | When to Use                               | Example                          |
| ------------------- | ----------------------------------------- | -------------------------------- |
| **Fixed Window**    | window size is constant                   | max sum of size k                |
| **Variable Window** | need longest/shortest substring condition | no repeated characters / sum ‚â• k |

---

# ‚ú® Want Practice?

I can give you **10 sliding-window questions** in increasing difficulty or walk through any specific problem such as:

* LeetCode 3 (Longest Substring)
* LeetCode 209 (Min Subarray Length)
* LeetCode 1456 (Max Vowels)
* LeetCode 904 (Fruit Into Baskets)
* LeetCode 992 (Subarrays with K different integers)

Just tell me **which one you want next**!
