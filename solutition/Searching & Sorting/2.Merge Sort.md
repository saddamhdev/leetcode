Here is the **easiest, step-by-step explanation** of **Merge Sort** with **diagram-style examples** and **clean Java code**, just like how we practiced Binary Search.

---

# ğŸ”„ **Merge Sort (Divide and Conquer Algorithm)**

Merge Sort is a **recursive**, **divide-and-conquer** sorting algorithm.

It works in 3 steps:

### âœ” Step 1: **Divide**

Split the array into two halves until each part becomes a single element.

### âœ” Step 2: **Conquer**

Sort the left part and sort the right part (recursively).

### âœ” Step 3: **Combine (Merge)**

Merge the two sorted halves into one sorted array.

---

# ğŸ˜ Why Merge Sort is Powerful?

| Feature              | Explanation             |
| -------------------- | ----------------------- |
| **Time Complexity**  | O(n log n) in all cases |
| **Stable Sort**      | Yes                     |
| **Uses recursion**   | Yes                     |
| **Space Complexity** | O(n)                    |

---

# ğŸ” **Step-by-Step Visual Example**

Sort the array:

```
[8, 3, 5, 4, 7, 6, 1, 2]
```

---

## 1ï¸âƒ£ **Divide Phase (Recursive Splitting)**

```
[8, 3, 5, 4, 7, 6, 1, 2]
            |
      Split into halves
```

```
Left:  [8, 3, 5, 4]
Right: [7, 6, 1, 2]
```

Split further:

```
[8, 3, 5, 4] â†’ [8, 3] and [5, 4]
[7, 6, 1, 2] â†’ [7, 6] and [1, 2]
```

Split again:

```
[8, 3] â†’ [8] [3]
[5, 4] â†’ [5] [4]
[7, 6] â†’ [7] [6]
[1, 2] â†’ [1] [2]
```

Now all pieces are size 1 â†’ **Division complete**.

---

## 2ï¸âƒ£ **Merge Phase (Combine Sorted Arrays)**

Start merging back in sorted order.

### Merge [8] and [3] â†’

```
[3, 8]
```

### Merge [5] and [4] â†’

```
[4, 5]
```

### Merge results:

```
[3, 8] + [4, 5] â†’ [3, 4, 5, 8]
```

Same for right side:

```
[7] + [6] â†’ [6, 7]
[1] + [2] â†’ [1, 2]
```

Then:

```
[6, 7] + [1, 2] â†’ [1, 2, 6, 7]
```

---

## 3ï¸âƒ£ **Final Merge**

Merge left & right:

```
[3, 4, 5, 8] + [1, 2, 6, 7]

â†’ [1, 2, 3, 4, 5, 6, 7, 8]
```

ğŸ‰ Sorted!

---

# ğŸ’» **Java Code (Clean + Best Practice)**

### ğŸ”¹ Main function

```java
public void mergeSort(int[] nums) {
    if (nums.length < 2) return;
    mergeSort(nums, 0, nums.length - 1);
}
```

### ğŸ”¹ Recursive function

```java
private void mergeSort(int[] nums, int left, int right) {
    if (left >= right) return;

    int mid = left + (right - left) / 2;

    mergeSort(nums, left, mid);
    mergeSort(nums, mid + 1, right);

    merge(nums, left, mid, right);
}
```

### ğŸ”¹ Merge function

```java
private void merge(int[] nums, int left, int mid, int right) {
    int[] temp = new int[right - left + 1];
    int i = left;      // left part pointer
    int j = mid + 1;   // right part pointer
    int k = 0;

    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            temp[k++] = nums[i++];
        } else {
            temp[k++] = nums[j++];
        }
    }

    // copy remaining elements
    while (i <= mid) temp[k++] = nums[i++];
    while (j <= right) temp[k++] = nums[j++];

    // copy from temp back to original
    for (int x = 0; x < temp.length; x++) {
        nums[left + x] = temp[x];
    }
}
```

---

# ğŸ§  Key Ideas to Remember

### âœ” Merge sort = divide + recurse + merge

### âœ” Recursion tree height = log n

### âœ” Merging each level = O(n)

### âœ” Total time = O(n log n)

### âœ” Stable, safe, reliable sorting method

---

# Want more?

I can explain:

âœ“ Quick Sort
âœ“ Bubble/Selection/Insertion Sort
âœ“ Merge Sort recursion tree diagram
âœ“ Merge sort dry-run on any array you give
âœ“ Interview-level merge sort questions (LeetCode)

Just tell me!
