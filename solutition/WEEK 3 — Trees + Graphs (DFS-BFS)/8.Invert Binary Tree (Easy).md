ржирзАржЪрзЗ **Invert Binary Tree (Easy)** ржкрзБрж░рзЛржкрзБрж░рж┐ рж╕рж╣ржЬ ржнрж╛рж╖рж╛рзЯ, ржЙржжрж╛рж╣рж░ржгрж╕рж╣, рж╕рзНржЯрзЗржк-ржмрж╛ржЗ-рж╕рзНржЯрзЗржк ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░ржЫрж┐ред

---

# ЁЯМ│ **Invert Binary Tree тАУ рж╕ржорж╕рзНржпрж╛ ржХрзА?**

**Definition:**
ржПржХржЯрж┐ Binary Tree ржжрзЗржУрзЯрж╛ ржерж╛ржХржмрзЗред рждрзЛржорж╛ржХрзЗ рж╕рзЗржЗ ржЯрзНрж░рж┐-ржЯрж╛ржХрзЗ **ржорж┐рж░рж░** ржХрж░рждрзЗ рж╣ржмрзЗред

ржЕрж░рзНржерж╛рзО:

* ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ **left child тЖФ right child** swap ржХрж░рждрзЗ рж╣ржмрзЗред
* ржкрзБрж░рзЛ ржЯрзНрж░рж┐ ржЬрзБрзЬрзЗ ржПржХржЗ ржХрж╛ржЬ рж╣ржмрзЗред

---

## ЁЯУМ ржЙржжрж╛рж╣рж░ржг

ржзрж░рж┐ рждрзЛржорж╛рж░ ржЯрзНрж░рж┐:

```
        4
      /   \
     2     7
    / \   / \
   1   3 6   9
```

**Invert ржХрж░рж╛рж░ ржкрж░рзЗ тЖТ**

```
        4
      /   \
     7     2
    / \   / \
   9   6 3   1
```

рж╕ржм left-right swap рж╣рзЯрзЗржЫрзЗред

---

# ЁЯза **ржЗржиржЯрзБржЗрж╢ржи (ржХрж┐ржнрж╛ржмрзЗ ржнрж╛ржмржмрзЗ?)**

* `root` ржирзЛржб ржирж╛ржУ
* рждрж╛рж░ `left` ржПржмржВ `right` swap ржХрж░рзЛ
* рждрж╛рж░ржкрж░ recursively/iteratively ржПржХржЗ ржХрж╛ржЬ ржХрж░рзЛ:

  * left subtree
  * right subtree

---

# ЁЯФе Recursive Solution (most common & simplest)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        // Swap
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        // Recursively invert left & right subtree
        invertTree(root.left);
        invertTree(root.right);

        return root;
    }
}
```

---

# ЁЯзй Step-by-step Understanding

ржЪрж▓ example tree ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐:

```
        4
      /   \
     2     7
```

### 1я╕ПтГг Call invertTree(4)

* Swap children:

  * left=2 ржПржмржВ right=7 тЖТ swap тЖТ 4 ржПрж░ ржирж┐ржЪрзЗ ржПржЦржи 7 left ржУ 2 right
* ржПрж░ржкрж░:

  * invertTree(7)
  * invertTree(2)

---

### 2я╕ПтГг Call invertTree(7)

* Swap children:

  * left=6 тЖФ right=9
* рждрж╛рж░ржкрж░ recursive call:

  * invertTree(9)
  * invertTree(6)
* ржжрзБржЯрзЛрждрзЗржЗ null child тЖТ ржХрж┐ржЫрзБ ржХрж░рж╛рж░ ржирзЗржЗ

---

### 3я╕ПтГг Call invertTree(2)

* Swap children:

  * left=1 тЖФ right=3
* рждрж╛рж░ржкрж░ recursive call:

  * invertTree(3)
  * invertTree(1)
* ржжрзБржЯрзЛрждрзЗржЗ null child тЖТ done

---

## ЁЯОп Final inverted tree:

```
        4
      /   \
     7     2
    / \   / \
   9   6 3   1
```

---

# ЁЯза Iterative Solution (using Queue)

ржпржжрж┐ BFS ржжрж┐рзЯрзЗ ржХрж░рждрзЗ ржЪрж╛ржУ:

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            TreeNode node = q.poll();

            // swap
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;

            // push children
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }

        return root;
    }
}
```

---

# ЁЯФе Summary тАФ ржПржХ ржмрж╛ржХрзНржпрзЗ

> Invert Binary Tree = ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ left ржПржмржВ right child swap ржХрж░рзЗ ржжрж╛ржУ тЖТ ржкрзБрж░рзЛ ржЯрзНрж░рж┐ ржорж┐рж░рж░ рж╣рзЯрзЗ ржпрж╛ржмрзЗред

---

# ржЪрж╛ржЗрж▓рзЗ Dry Run ржХрж░рзЗ ржжрзЗржЦрж╛ржмрзЛ тЬФя╕П

рждрзБржорж┐ ржпрзЗ ржЯрзНрж░рж┐ ржмрж▓ржмрзЗ рж╕рзЗржЯрж╛рж░ ржЙржкрж░ рж╣рж╛рждрзЗ ржзрж░рзЗ inversion ржХрж░рзЗ ржжрзЗржЦрж╛ржмрзЛред
