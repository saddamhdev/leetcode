Below is the **TOP 10 most frequently asked Binary Tree LeetCode problems**, each with:

* **Problem Description (short & clear)**
* **Approach**
* **Time Complexity**
* **Java Solution (clean and optimal)**

This is the perfect **interview preparation set**.

---

# âœ… **1. Maximum Depth of Binary Tree (Easy)**

ğŸ“Œ *LeetCode 104*

## **Problem**

Find the height (maximum depth) of the binary tree.

## **Approach**

Use recursion:
Height = `1 + max(height(left), height(right))`

### â± Time Complexity: **O(n)**

### ğŸ’¾ Space: **O(h)** where h = height

## âœ… **Java Solution**

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

---

# âœ… **2. Same Tree (Easy)**

ğŸ“Œ *LeetCode 100*

## **Problem**

Check if two binary trees are exactly identical.

## **Approach**

* If both null â†’ true
* If one null â†’ false
* Compare values
* Recursively check left and right

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;

        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

---

# âœ… **3. Symmetric Tree (Easy)**

ğŸ“Œ *LeetCode 101*

## **Problem**

Check if tree is mirror of itself.

## **Approach**

Compare left subtree with mirror of right subtree.

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isMirror(root.left, root.right);
    }

    boolean isMirror(TreeNode a, TreeNode b) {
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;
        return (a.val == b.val) &&
               isMirror(a.left, b.right) &&
               isMirror(a.right, b.left);
    }
}
```

---

# âœ… **4. Binary Tree Level Order Traversal (Medium)**

ğŸ“Œ *LeetCode 102*

## **Problem**

Return values level-by-level (BFS).

## **Approach**

Use **Queue**, visit level by level.

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            int size = q.size();
            List<Integer> level = new ArrayList<>();

            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                level.add(node.val);
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            result.add(level);
        }
        return result;
    }
}
```

---

# âœ… **5. Invert Binary Tree (Easy)**

ğŸ“Œ *LeetCode 226*

## **Problem**

Swap left and right children of all nodes.

## **Approach**

Swap recursively.

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        invertTree(root.left);
        invertTree(root.right);

        return root;
    }
}
```

---

# âœ… **6. Diameter of Binary Tree (Medium)**

ğŸ“Œ *LeetCode 543*

## **Problem**

Longest path between two nodes.

## **Approach**

Diameter = max(leftHeight + rightHeight)

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    int diameter = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        height(root);
        return diameter;
    }

    int height(TreeNode node) {
        if (node == null) return 0;

        int left = height(node.left);
        int right = height(node.right);

        diameter = Math.max(diameter, left + right);

        return 1 + Math.max(left, right);
    }
}
```

---

# âœ… **7. Lowest Common Ancestor (Medium)**

ğŸ“Œ *LeetCode 236*

## **Problem**

Return the LCA of two nodes.

## **Approach**

* If root is p or q â†’ return root
* Search left & right
* If both non-null â†’ LCA is root

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left != null && right != null) return root;

        return left != null ? left : right;
    }
}
```

---

# âœ… **8. Path Sum (Easy)**

ğŸ“Œ *LeetCode 112*

## **Problem**

Check if rootâ†’leaf path equals target sum.

## **Approach**

Subtract node.val at each step.

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;

        if (root.left == null && root.right == null)
            return targetSum == root.val;

        return hasPathSum(root.left, targetSum - root.val) ||
               hasPathSum(root.right, targetSum - root.val);
    }
}
```

---

# âœ… **9. Balanced Binary Tree (Easy/Medium)**

ğŸ“Œ *LeetCode 110*

## **Problem**

Check if height difference â‰¤ 1.

## **Approach**

Return **-1** if unbalanced.

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }

    int height(TreeNode node) {
        if (node == null) return 0;

        int left = height(node.left);
        int right = height(node.right);

        if (left == -1 || right == -1) return -1;
        if (Math.abs(left - right) > 1) return -1;

        return 1 + Math.max(left, right);
    }
}
```

---

# ğŸ”¥ **10. Binary Tree Maximum Path Sum (Hard)**

ğŸ“Œ *LeetCode 124*

## **Problem**

Find max path sum (path can go through any nodes).

## **Approach**

At each node:

* calculate best left path
* calculate best right path
* update global max

### â± O(n)

## âœ… **Java Solution**

```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    int maxGain(TreeNode node) {
        if (node == null) return 0;

        int left = Math.max(maxGain(node.left), 0);
        int right = Math.max(maxGain(node.right), 0);

        int currentPath = node.val + left + right;

        maxSum = Math.max(maxSum, currentPath);

        return node.val + Math.max(left, right);
    }
}
```

---

# ğŸ‰ Done!

These **10 problems** cover **90% of real interview Binary Tree questions**.

---

# ğŸ“¦ Want Full â€œBinary Tree Coding Sheet (30 Problems)â€?

I can give:

### âœ” 30 most-asked questions

### âœ” All solutions in Java

### âœ” Easy â†’ Medium â†’ Hard category

### âœ” Your WEEK-3 PDF

Just say: **â€œGive me full Binary Tree Sheetâ€**
