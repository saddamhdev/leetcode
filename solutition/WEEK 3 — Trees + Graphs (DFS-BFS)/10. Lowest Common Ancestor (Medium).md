Here is the **Lowest Common Ancestor (LCA) of a Binary Tree â€” Medium** explained **step-by-step**, exactly like the previous LeetCode explanations you liked.

---

# ðŸ”¥ **Lowest Common Ancestor of a Binary Tree (Medium)**

**LeetCode #236**

---

# âœ… **Problem Summary**

You are given a **binary tree** and two nodes `p` and `q`.
You must find their **Lowest Common Ancestor** (LCA).

ðŸ‘‰ **LCA definition**:
The *lowest* (deepest) node in the tree that has **both p and q as descendants**.
(A node can also be a descendant of itself!)

---

# âœ… **Intuition (Very Important)**

We do a **DFS** (depth-first search) from root:

### For every node, check three things:

1. **Left subtree** â†’ does it contain `p` or `q`?
2. **Right subtree** â†’ does it contain `p` or `q`?
3. **Current node == p or q?**

Now the key rule:

### â­ If **2 out of these 3** become true â†’ this node is the **LCA**.

---

# ðŸ”¥ **Visual Example**

Suppose we search LCA of **5** and **1**:

```
        3
      /   \
     5     1
    / \
   6   2
```

* `p = 5`, `q = 1`
* DFS finds:
  â€¢ Left subtree returns true for node 5
  â€¢ Right subtree returns true for node 1
  ðŸ‘‰ So node **3** is LCA.

---

# âœ… **Step-by-Step DFS Logic**

At each node:

### 1ï¸âƒ£ Base Case

If node is `null` â†’ return `false`.

If `node == p` or `node == q` â†’ return `true`.

### 2ï¸âƒ£ Recursive Case

Check left subtree â†’ `left = dfs(node.left)`
Check right subtree â†’ `right = dfs(node.right)`

### 3ï¸âƒ£ LCA condition

If:

* `left == true` **and** `right == true`
  â†’ This node is LCA.

OR

* (`node == p` or `node == q`) **and** (one subtree is true)
  â†’ This node is LCA.

---

# ðŸ§  Full Code (Java)
à¦šà¦²à§‹ à¦à¦•à¦¦à¦® à¦§à§€à¦°à§‡ à¦§à§€à¦°à§‡ à¦®à¦¾à¦¥à¦¾à¦° à¦­à§‡à¦¤à¦° à¦°à¦¾à¦¨ à¦•à¦°à¦¾à¦‡ ðŸ˜„
Weâ€™ll explain this code **line by line + full dry run**.

---

## ðŸ§© Code (single method)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        
        // 1ï¸âƒ£ Base case
        if (root == null || root == p || root == q) {
            return root;
        }

        // 2ï¸âƒ£ Search in left and right subtrees
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 3ï¸âƒ£ If p and q found in different subtrees â†’ root is LCA
        if (left != null && right != null) {
            return root;
        }

        // 4ï¸âƒ£ Otherwise return non-null result (either left or right)
        return (left != null) ? left : right;
    }
}
```

---

## 1ï¸âƒ£ What is the main idea?

We use **recursion** (DFS):

* Each call tries to answer:
  ðŸ‘‰ â€œIn the subtree rooted at `root`, is there `p` or `q`?
  If yes, return the node; if not, return `null`.â€

* When we come to a node where:

  * Left side gives non-null (found one of them)
  * Right side gives non-null (found the other)
    â†’ That `root` is the **Lowest Common Ancestor**.

---

## 2ï¸âƒ£ Step-by-step: What does each line do?

### ðŸ§± Base case

```java
if (root == null || root == p || root == q) {
    return root;
}
```

This handles 3 situations:

1. `root == null`

   * We went past a leaf â†’ nothing here â†’ return `null`.

2. `root == p`

   * We found node `p`.
   * Return this node upwards to let parents know: â€œI found p hereâ€.

3. `root == q`

   * Same logic but for `q`.

> So this line says:
> **If Iâ€™m at nothing (null) or exactly at p or q, then just return myself.**

---

### ðŸ” Recursive calls

```java
TreeNode left = lowestCommonAncestor(root.left, p, q);
TreeNode right = lowestCommonAncestor(root.right, p, q);
```

* We go **down to the left child** and ask:

  > â€œDoes your subtree contain p or q?â€

* Then go **down to the right child** and ask the same.

* Each side will return:

  * `null` â†’ if neither p nor q in that subtree
  * `p`   â†’ if found p (possibly LCA deeper)
  * `q`   â†’ if found q
  * Or some ancestor node that is LCA, from deeper recursion.

---

### âš– LCA Condition

```java
if (left != null && right != null) {
    return root;
}
```

* If **left is not null** â†’ left subtree found something (p or q or an LCA).
* If **right is not null** â†’ right subtree also found something.

So:

* One side has p
* Other side has q
  â†’ This `root` is the **lowest node** where both sides meet.
  ðŸ‘‰ So we return `root` as the LCA.

---

### ðŸ”š Final return

```java
return (left != null) ? left : right;
```

Here, 3 possibilities:

1. `left != null && right == null`
   â†’ Only left side has something â†’ return `left`.

2. `left == null && right != null`
   â†’ Only right side has something â†’ return `right`.

3. `left == null && right == null`
   â†’ Neither side has anything â†’ return `null`.

---

## 3ï¸âƒ£ Full Dry Run with Example

Take this tree:

```text
        3
      /   \
     5     1
    / \   / \
   6   2 0   8
      / \
     7   4
```

Let:

* `p = 5`
* `q = 1`
  LCA should be `3`.

Call:

```java
lowestCommonAncestor(3, 5, 1)
```

---

### ðŸ” Step 1: At node 3

`root = 3`

* Base case?

  * `root == null`? âŒ
  * `root == p or q`? (`3 == 5` or `3 == 1`)? âŒ
    â†’ So we go to recursion.

* Call left and right:

```java
left = lowestCommonAncestor(3.left = 5, p=5, q=1);
right = lowestCommonAncestor(3.right = 1, p=5, q=1);
```

Weâ€™ll evaluate them one by one.

---

### ðŸ” Step 2: Go left to node 5

Call:

```java
lowestCommonAncestor(5, 5, 1)
```

At node 5:

* Base case:

  * `root == null`? âŒ
  * `root == p or q`?
    â†’ `root == p` âœ… (`5 == 5`)
* So we **return 5 immediately**.

Thus:

```java
left = 5
```

We DO NOT go further down from 5, because base case returned early.

---

### ðŸ” Step 3: Go right to node 1

Call:

```java
lowestCommonAncestor(1, 5, 1)
```

At node 1:

* Base case:

  * `root == null`? âŒ
  * `root == p or q`?
    â†’ `root == q` âœ… (`1 == 1`)
* So we **return 1 immediately**.

Thus:

```java
right = 1
```

---

### ðŸ” Step 4: Back at node 3, combine results

Now weâ€™re back in the first call at `root = 3`:

We have:

```java
left = 5
right = 1
```

Check LCA condition:

```java
if (left != null && right != null) {
    return root;  // root is 3
}
```

* `left != null` âœ… (itâ€™s 5)
* `right != null` âœ… (itâ€™s 1)

So condition is true â†’ we `return 3`.

âœ… Final answer: **LCA = 3**

---

## 4ï¸âƒ£ Second Example: When one node is ancestor of the other

Same tree, now:

* `p = 5`
* `q = 4`
  LCA should be **5**, because 5 is the ancestor of 4 and also one of the nodes.

Call:

```java
lowestCommonAncestor(3, 5, 4)
```

### Step A: At node 3

Not null, not p or q.

Call left & right:

```java
left = lowestCommonAncestor(5, 5, 4);
right = lowestCommonAncestor(1, 5, 4);
```

### Step B: At node 5

Call:

```java
lowestCommonAncestor(5, 5, 4)
```

* Base case:

  * `root == p` âœ… (5 == 5)
* So directly: `return 5`.

Thus `left = 5`.

### Step C: At node 1

Call:

```java
lowestCommonAncestor(1, 5, 4)
```

* Not p, not q, not null.

Now:

```java
left = lowestCommonAncestor(0, 5, 4); // returns null (no p, q under 0)
right = lowestCommonAncestor(8, 5, 4); // returns null (no p, q under 8)
```

So at node 1:

```java
left = null
right = null

if (left != null && right != null) {  // false
    ...
}
return (left != null) ? left : right; // both null â†’ returns null
```

So `right = null` for node 3.

### Step D: Back at node 3

Now:

```java
left = 5
right = null
```

Check:

```java
if (left != null && right != null) { // false
    return root;
}
return (left != null) ? left : right;
// left != null â†’ return left â†’ return 5
```

So final answer: **LCA = 5**

---

## 5ï¸âƒ£ Super short intuition summary

You can remember it like this:

> â€œà¦†à¦®à¦¿ à¦¨à¦¿à¦š à¦¥à§‡à¦•à§‡ à¦‰à¦ªà¦°à§‡ à¦‰à¦ à§‡ à¦†à¦¸à¦¤à§‡ à¦†à¦¸à¦¤à§‡ à¦–à§à¦à¦œà¦›à¦¿ p à¦†à¦° q à¦•à§‡à¥¤
>
> à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦ªà§à¦°à¦¥à¦®à¦¬à¦¾à¦° **à¦à¦•à¦Ÿà¦¾ subtree à¦¥à§‡à¦•à§‡ p/q à¦†à¦° à¦†à¦°à§‡à¦•à¦Ÿà¦¾ subtree à¦¥à§‡à¦•à§‡ p/q** à¦ªà¦¾à¦‡,
> à¦¸à§‡à¦–à¦¾à¦¨à§‡à¦‡ à¦†à¦®à¦¾à¦° LCAà¥¤
>
> Recursion à¦¸à¦¬à¦•à¦¿à¦›à§ à¦•à¦°à§‡ à¦¦à§‡à§Ÿ à¦†à¦®à¦¾à¦° à¦œà¦¨à§à¦¯à¥¤â€

Or in English:

> We search bottom-up.
> As soon as a node sees `p/q` in left and `p/q` in right,
> that node is the **LCA**.

---

If you want, next I can:

* Draw this as a **recursion tree** with arrows, or
* Explain in Bangla only with a story-style narration.
