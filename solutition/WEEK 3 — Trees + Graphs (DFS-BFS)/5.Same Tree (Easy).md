ржжрж╛рж░рзБржг, ржПржмрж╛рж░ **Same Tree (LeetCode 100)** ржЯрж╛ ржПржХржжржо **step by step** ржмрзЛржЭрж╛ржЗ тАУ ржарж┐ржХ ржпрзЗржоржиржЯрж╛ ржЖржорж░рж╛ `maxDepth` ржПрж░ ржЬржирзНржп ржХрж░рзЗржЫрж┐рж▓рж╛ржо ЁЯШД

---

# ЁЯУМ Problem: Same Tree (Easy) тАФ LeetCode 100

**Question:**
рждрзЛржорж╛ржХрзЗ ржжрзБржЗржЯрж╛ binary tree ржжрзЗржУрзЯрж╛ ржерж╛ржХржмрзЗ: `p` ржЖрж░ `q`.
Check ржХрж░рждрзЗ рж╣ржмрзЗ:

ЁЯСЙ **ржЙржнрзЯ tree ржХрж┐ ржПржХржжржо ржПржХржЗ?**
ржорж╛ржирзЗтАФ

1. Structure ржПржХржЗ? (ржирзЛржбрзЗрж░ ржЬрж╛рзЯржЧрж╛/shape)
2. ржкрзНрж░рждрж┐ржЯрж┐ corresponding node-ржПрж░ value ржПржХржЗ?

ржпржжрж┐ ржжрзБржЗржЯрж╛ржЗ ржорж┐рж▓рзЗ ржпрж╛рзЯ тЖТ `true`
ржирж╛ рж╣рж▓рзЗ тЖТ `false`

---

# ЁЯза Recursion ржнрж╛ржмржирж╛

ржПржХржЯрж╛ function ржзрж░рзЛ:

```java
boolean isSameTree(TreeNode p, TreeNode q)
```

ржкрзНрж░рждрж┐ржЯрж╛ ржзрж╛ржкрзЗ ржЖржорж░рж╛ ржПржЗ рждрж┐ржиржЯрж╛ ржХрзЗрж╕ ржжрзЗржЦрж┐:

1я╕ПтГг **ржжрзБржЗржЯрж╛ржЗ null** тЖТ ржжрзБржЗ ржжрж┐ржХрзЗржЗ ржЧрж╛ржЫ рж╢рзЗрж╖ тЖТ тЬЕ same
2я╕ПтГг **ржПржХржЯрж╛ null, ржЖрж░рзЗржХржЯрж╛ null ржирж╛** тЖТ ржПржХржжрж┐ржХрзЗ node ржЖржЫрзЗ, ржПржХржжрж┐ржХрзЗ ржирзЗржЗ тЖТ тЭМ not same
3я╕ПтГг **ржжрзБржЗржЯрж╛ржЗ non-null** тЖТ value check ржХрж░ржм + left/right рж╕рж╛ржмржЯрзНрж░рж┐ check ржХрж░ржм

---

# тЬЕ Java Solution (ржпрзЗржЯрж╛ LeetCode-ржП рж▓рж┐ржЦрж┐)

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // 1. ржжрзБржЯрзЛржЗ null тЖТ same
        if (p == null && q == null) return true;

        // 2. ржПржХржЯрж╛ржпрж╝ null ржЖрж░ ржЖрж░рзЗржХржЯрж╛ржпрж╝ ржирж╛ тЖТ different
        if (p == null || q == null) return false;

        // 3. value ржЖрж▓рж╛ржжрж╛ рж╣рж▓рзЗ тЖТ different
        if (p.val != q.val) return false;

        // 4. left ржПржмржВ right рж╕рж╛ржмржЯрзНрж░рж┐рж░ рж░рзЗржЬрж╛рж▓рзНржЯ AND ржХрж░рзЗ ржжрзЗржЦржм
        return isSameTree(p.left, q.left) &&
               isSameTree(p.right, q.right);
    }
}
```

---

## ЁЯФН Step by Step Dry Run тАУ Example 1 (Trees are SAME)

ржжрзБржЗржЯрж╛ tree ржзрж░рж┐:

### Tree p:

```text
        1
       / \
      2   3
```

### Tree q:

```text
        1
       / \
      2   3
```

ржПржЦржи `isSameTree(p, q)` ржХрж┐ржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░ржмрзЗ ржжрзЗржЦрж┐ ЁЯСЗ

---

### ЁЯФ╣ Step 1: `isSameTree(p=1, q=1)`

* ржжрзБржЯрзЛржЗ null ржирж╛ тЖТ base case 1 ржирж╛
* ржПржХржЯрж╛рзЯ null, ржЖрж░рзЗржХржЯрж╛рзЯ ржирж╛ тЖТ base case 2 ржирж╛
* `p.val = 1`, `q.val = 1` тЖТ equal тЬЕ

ржПржЦржи ржЖржорж░рж╛ ржХрж░ржм:

```java
leftSame  = isSameTree(p.left(2), q.left(2))
rightSame = isSameTree(p.right(3), q.right(3))

return leftSame && rightSame;
```

ржПржЦржи ржЖржЧрзЗ left side ржП ржпрж╛ржЗ ЁЯСЗ

---

### ЁЯФ╣ Step 2: `isSameTree(p=2, q=2)`

* null ржирж╛, null ржирж╛ тЬЕ
* value check: `2 == 2` тЬЕ

ржЖржмрж╛рж░ split:

```java
leftSame  = isSameTree(p.left(null), q.left(null))
rightSame = isSameTree(p.right(null), q.right(null))
```

---

#### ЁЯФ╕ Step 2.1: `isSameTree(null, null)`

* ржжрзБржЯрзЛржЗ null тЖТ `return true` тЬЕ

#### ЁЯФ╕ Step 2.2: `isSameTree(null, null)`

* ржЖржмрж╛рж░ ржжрзБржЯрзЛржЗ null тЖТ `return true` тЬЕ

ржПржЦржи node `2` ржПрж░ ржЬржирзНржп:

```text
leftSame  = true
rightSame = true

return true && true = true
```

тЪб ржорж╛ржирзЗ: left subtree (2) same тЬЕ

---

### ЁЯФ╣ Step 3: `isSameTree(p=3, q=3)`

ржПржХржЗ pattern:

* ржжрзБржЯрзЛржЗ non-null
* `3 == 3` тЬЕ
* ржжрзБржЯрзЛ child-ржЗ `null`

So:

```text
isSameTree(null, null) тЖТ true
isSameTree(null, null) тЖТ true

return true && true = true
```

тЪб right subtree (3)ржУ same тЬЕ

---

### ЁЯФ╣ Step 4: Back to root (1)

ржПржЦржи root `1` ржП:

```text
leftSame  = true   (from node 2)
rightSame = true   (from node 3)

return true && true = true
```

тЬЕ Final Answer: **Trees are SAME** тЖТ `true`

---

## тЭМ Example 2: ржпрзЗржЦрж╛ржирзЗ ржЧрж╛ржЫ ржжрзБржЗржЯрж╛ ржЖрж▓рж╛ржжрж╛

ржзрж░рж┐:

### Tree p:

```text
        1
       / \
      2   3
```

### Tree q:

```text
        1
       / \
      2   4
```

ржПржЦржи `isSameTree(p, q)` dry run ржХрж░рж┐ ЁЯСЗ

---

### ЁЯФ╣ Step 1: `isSameTree(1, 1)`

* ржжрзБржЯрзЛржЗ non-null
* `1 == 1` тЬЕ
* left/right ржЪрзЗржХ ржХрж░ржм:

```java
leftSame  = isSameTree(2, 2)
rightSame = isSameTree(3, 4)
```

---

### ЁЯФ╣ Step 2: `isSameTree(2, 2)`

* `2 == 2` тЬЕ
* ржжрзБржЯрзЛ child `null` тЖТ ржжрзБржЯрзЛржЗ true
* So ржПржЯрж┐ `true` рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржмрзЗ

---

### ЁЯФ╣ Step 3: `isSameTree(3, 4)`

ржПржЦрж╛ржирзЗржЗ ржкрж╛рж░рзНржержХрзНржп:

* ржжрзБржЯрзЛржЗ non-null тЬЕ
* ржХрж┐ржирзНрждрзБ:

```java
if (p.val != q.val) return false;
```

ржПржЦрж╛ржирзЗ `p.val = 3`, `q.val = 4` тЖТ not equal

рждрж╛ржЗ:

```text
return false
```

---

### ЁЯФ╣ Step 4: Back to root

ржПржЦржи root `1` ржП:

```text
leftSame  = true
rightSame = false

return true && false = false
```

тЭМ Final Answer: **Trees are NOT SAME** тЖТ `false`

---

## ЁЯза ржХрзА ржХрзА ржмрзБржЭрж▓рзЗ ржПржЗ problem ржЯрж╛ strong рж╣ржмрзЗ?

1. **Base cases**:

   * ржжрзБржЯрзЛржЗ null тЖТ same
   * ржПржХржЯрж╛ржЗ null тЖТ not same
   * value ржЖрж▓рж╛ржжрж╛ тЖТ not same

2. Recursion ржжрзБржЗржЯрж╛ tree **ржПржХрж╕рж╛ржерзЗ traverse** ржХрж░ржЫрзЗ:

   * `p.left` vs `q.left`
   * `p.right` vs `q.right`

3. рж╢рзЗрж╖рзЗ рж╕ржм level-ржП `true` рж╣рждрзЗ рж╣ржмрзЗ, рждрж╛ржЗ ржЖржорж░рж╛ `&&` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐ред

---

## ЁЯОп ржЫрзЛржЯ shortcut line (interview-ржП ржмрж▓рж╛рж░ ржЬржирзНржп):

> тАЬI recursively compare both trees:
> if both nodes are null, they are equal;
> if one is null or values differ, theyтАЩre not;
> otherwise I check left and right subtrees and return the AND of both.тАЭ

---

ржЪрж╛ржУ рждрзЛ, ржкрж░рзЗрж░ржЯрж╛ рж╣рж┐рж╕рж╛ржмрзЗ ржЖржорж░рж╛
ЁЯСЙ **Symmetric Tree (LeetCode 101)**
ржмрж╛
ЁЯСЙ **Invert Binary Tree (LeetCode 226)**
ржПржнрж╛ржмрзЗржЗ **step-by-step dry run** ржХрж░рзЗ ржмрзБржЭрзЗ ржирж┐рждрзЗ ржкрж╛рж░рж┐ред

ржПржХржЯрж╛ ржмрзЗржЫрзЗ ржмрж▓рзЛ: **тАЬExplain Symmetric Tree step-by-stepтАЭ** ржЕржержмрж╛ ржЕржирзНржп ржпрзЗржХрзЛржирзЛржЯрж╛ ЁЯЩВ
