Here is a **clean, interview-ready, exam-friendly Binary Tree explanation with complete Java code**, including:

* Node class
* Inorder / Preorder / Postorder
* Level Order (BFS)
* Height, Count nodes, Leaf count
* Insert (for simple tree)
* Practice problems

Perfect for your **Week 3 ‚Äî Trees + DFS/BFS**.

---

# üå≥ **Binary Tree (Java Implementation)**

---

# ‚úÖ **1. Node Class**

```java
class Node {
    int value;
    Node left, right;

    Node(int value) {
        this.value = value;
        left = right = null;
    }
}
```

---

# ‚úÖ **2. Binary Tree Class**

```java
class BinaryTree {
    Node root;

    BinaryTree() {
        root = null;
    }
}
```

---

# üî• **3. DFS Traversals (Recursive)**

## **A. Inorder (Left ‚Üí Root ‚Üí Right)**

```java
void inorder(Node node) {
    if (node == null) return;
    inorder(node.left);
    System.out.print(node.value + " ");
    inorder(node.right);
}
```

---

## **B. Preorder (Root ‚Üí Left ‚Üí Right)**

```java
void preorder(Node node) {
    if (node == null) return;
    System.out.print(node.value + " ");
    preorder(node.left);
    preorder(node.right);
}
```

---

## **C. Postorder (Left ‚Üí Right ‚Üí Root)**

```java
void postorder(Node node) {
    if (node == null) return;
    postorder(node.left);
    postorder(node.right);
    System.out.print(node.value + " ");
}
```

---

# üîµ **4. BFS (Level Order Traversal)**

Uses **Queue**.

```java
void levelOrder(Node root) {
    if (root == null) return;

    Queue<Node> queue = new LinkedList<>();
    queue.add(root);

    while (!queue.isEmpty()) {
        Node node = queue.poll();
        System.out.print(node.value + " ");

        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
    }
}
```

---

# üßÆ **5. Height of Binary Tree**

```java
int height(Node node) {
    if (node == null) return 0;
    return 1 + Math.max(height(node.left), height(node.right));
}
```

---

# üìä **6. Count Nodes**

```java
int countNodes(Node node) {
    if (node == null) return 0;
    return 1 + countNodes(node.left) + countNodes(node.right);
}
```

---

# üçÉ **7. Count Leaf Nodes (no children)**

```java
int countLeaf(Node node) {
    if (node == null) return 0;
    if (node.left == null && node.right == null) return 1;
    return countLeaf(node.left) + countLeaf(node.right);
}
```

---

# üîÅ **8. Insert Node (simple binary tree ‚Äî not BST)**

```java
Node insert(Node root, int value) {
    if (root == null) {
        root = new Node(value);
        return root;
    }

    Queue<Node> q = new LinkedList<>();
    q.add(root);

    while (!q.isEmpty()) {
        Node temp = q.poll();

        if (temp.left == null) {
            temp.left = new Node(value);
            break;
        } else q.add(temp.left);

        if (temp.right == null) {
            temp.right = new Node(value);
            break;
        } else q.add(temp.right);
    }

    return root;
}
```

---

# üìå **9. Full Example Code (Ready to Run)**

```java
import java.util.*;

class Node {
    int value;
    Node left, right;

    Node(int value) {
        this.value = value;
        left = right = null;
    }
}

class BinaryTree {

    Node root;

    // DFS Traversals
    void inorder(Node node) {
        if (node == null) return;
        inorder(node.left);
        System.out.print(node.value + " ");
        inorder(node.right);
    }

    void preorder(Node node) {
        if (node == null) return;
        System.out.print(node.value + " ");
        preorder(node.left);
        preorder(node.right);
    }

    void postorder(Node node) {
        if (node == null) return;
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.value + " ");
    }

    // BFS
    void levelOrder(Node root) {
        if (root == null) return;

        Queue<Node> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            Node temp = q.poll();
            System.out.print(temp.value + " ");

            if (temp.left != null) q.add(temp.left);
            if (temp.right != null) q.add(temp.right);
        }
    }

    // Height
    int height(Node node) {
        if (node == null) return 0;
        return 1 + Math.max(height(node.left), height(node.right));
    }

    // Count all nodes
    int countNodes(Node node) {
        if (node == null) return 0;
        return 1 + countNodes(node.left) + countNodes(node.right);
    }

    // Count leaf nodes
    int countLeaf(Node node) {
        if (node == null) return 0;
        if (node.left == null && node.right == null) return 1;
        return countLeaf(node.left) + countLeaf(node.right);
    }

    // Insert (not BST)
    Node insert(Node root, int value) {
        if (root == null) return new Node(value);

        Queue<Node> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            Node temp = q.poll();

            if (temp.left == null) {
                temp.left = new Node(value);
                break;
            } else q.add(temp.left);

            if (temp.right == null) {
                temp.right = new Node(value);
                break;
            } else q.add(temp.right);
        }
        return root;
    }
}

public class Main {
    public static void main(String[] args) {

        BinaryTree tree = new BinaryTree();

        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.print("Inorder: ");
        tree.inorder(tree.root);

        System.out.print("\nPreorder: ");
        tree.preorder(tree.root);

        System.out.print("\nPostorder: ");
        tree.postorder(tree.root);

        System.out.print("\nLevel Order: ");
        tree.levelOrder(tree.root);

        System.out.println("\nHeight: " + tree.height(tree.root));
        System.out.println("Total Nodes: " + tree.countNodes(tree.root));
        System.out.println("Leaf Nodes: " + tree.countLeaf(tree.root));
    }
}
```

---

# üéØ Want Binary Search Tree (BST) next?

I can give you:

* Insert / Search / Delete in BST
* Validate BST
* Balanced BST (AVL / Red-Black simple theory)
* BST problems (easy ‚Üí hard)

Just say: **‚ÄúExplain BST in Java‚Äù** or **‚ÄúBST full code‚Äù**.
