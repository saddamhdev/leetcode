Here is **WEEK 3 â€” Trees + Graphs (DFS/BFS)** in a clean, structured, student-friendly format.
This fits your *Machine Learning & Data Mining exam prep + coding interview practice* study plan.

---

# âœ… **WEEK 3 â€” Trees + Graphs (DFS/BFS) (Full Study Plan)**

---

# ğŸŒ³ **1. Tree Basics**

### âœ” What is a Tree?

A **tree** is:

* A connected graph
* With **no cycles**
* Having **N nodes â†’ N-1 edges**

### âœ” Important Terms:

| Term    | Meaning                                   |
| ------- | ----------------------------------------- |
| Root    | Starting node                             |
| Parent  | Node that connects to child               |
| Child   | Node below a parent                       |
| Leaf    | Node with no children                     |
| Depth   | Distance from root                        |
| Height  | Longest path from node to leaf            |
| Subtree | Tree formed by a node and its descendants |

---

# ğŸ” **2. Tree Traversal**

### Traversal means â€œvisit all nodes in some order.â€

## **A. DFS (Depth First Search)**

Goes **deep first**, then backtracks.

### 1ï¸âƒ£ Pre-order (Root â†’ Left â†’ Right)

### 2ï¸âƒ£ In-order (Left â†’ Root â†’ Right)

### 3ï¸âƒ£ Post-order (Left â†’ Right â†’ Root)

---

# ğŸ” **3. Graph Basics**

A **graph** is a set of nodes connected by edges.

### âœ” Types of Graphs

* Directed / Undirected
* Weighted / Unweighted
* Cyclic / Acyclic
* Connected / Disconnected

### âœ” Representation

| Representation   | Use Case                     |
| ---------------- | ---------------------------- |
| Adjacency List   | Sparse graph, efficient      |
| Adjacency Matrix | Dense graph, constant lookup |

---

# ğŸ”¥ **4. DFS & BFS â€” Core Algorithms**

## **DFS (Depth First Search)**

* Uses **stack** (or recursion)
* Good for:

  * Path finding
  * Cycle detection
  * Topological sorting
  * Connected components

**Pseudo-code:**

```
DFS(node):
    mark[node] = true
    for neighbor in graph[node]:
        if not mark[neighbor]:
            DFS(neighbor)
```

---

## **BFS (Breadth First Search)**

* Uses **queue**
* Good for:

  * Shortest path in unweighted graph
  * Level order traversal
  * Bipartite check

**Pseudo-code:**

```
BFS(start):
    queue = [start]
    mark[start] = true
    while queue:
        node = queue.pop(0)
        for neighbor in graph[node]:
            if not mark[neighbor]:
                mark[neighbor] = true
                queue.append(neighbor)
```

---

# ğŸ¯ **5. Important Concepts (Exam + Interview)**

### âœ” Connected Components

DFS/BFS count how many separate groups exist.

### âœ” Cycle Detection

* Undirected: DFS + track parent
* Directed: DFS + recursion stack

### âœ” Topological Sorting

Only for **DAG (Directed Acyclic Graph)**
Use **DFS** or **Kahnâ€™s BFS algorithm**.

### âœ” Bipartite Graph Check

Use **BFS coloring**.

### âœ” Shortest Path

* Unweighted â†’ BFS
* Weighted â†’ Dijkstra / Bellman-Ford

---

# ğŸ§  **6. Coding Problems You Must Practice**

## **Easy**

âœ” Level Order Traversal
âœ” Inorder / Preorder / Postorder
âœ” DFS / BFS on grid
âœ” Count islands (2D grid)

## **Medium**

âœ” Number of Connected Components
âœ” Detect Cycle in Undirected/Directed Graph
âœ” Clone Graph
âœ” Topological Sort
âœ” Shortest Path BFS
âœ” Binary Tree Diameter

## **Hard**

âœ” Word Ladder (BFS)
âœ” Minimum Knight Moves
âœ” Pacific Atlantic Water Flow
âœ” All Paths from Source to Target (DFS)

---

# ğŸ”¥ Want WEEK-3 Coding Sheet + Explanation + 40 Practice Problems?

If you want, Iâ€™ll give you:

* ğŸ“˜ **Study PDF**
* ğŸŒ² Tree traversal cheat-sheet
* ğŸŒ Graph theory cheatsheet
* ğŸ’» 40 coding problems
* ğŸ“ Expected exam questions
* ğŸ¯ Daily routine plan for Week-3

Just say **â€œGive the full WEEK-3 pack.â€**
