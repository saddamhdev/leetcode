Below is **clean, interview-grade documentation** for
**LeetCode 3770 â€“ Largest Prime from Consecutive Prime Sum**, written as if it were **official problem documentation + solution explanation**.
You can use this for **study, notes, interviews, or code review**.

---

# ğŸ“˜ Problem Documentation

## 3770. Largest Prime from Consecutive Prime Sum

**Difficulty:** Medium
**Topics:** Math, Prime Numbers, Sieve of Eratosthenes
**Constraints:**

* `1 â‰¤ n â‰¤ 5 Ã— 10^5`

---

## ğŸ” Problem Statement

You are given an integer `n`.

Return the **largest prime number â‰¤ n** that can be expressed as the **sum of one or more consecutive prime numbers starting from 2**.

If no such number exists, return `0`.

---

## ğŸ§  Key Observations

1. **The sum must start from prime number 2**

   * This restriction eliminates all sliding window or multi-start approaches.
   * There is **only one valid sequence**:

     ```
     2
     2 + 3
     2 + 3 + 5
     2 + 3 + 5 + 7
     ...
     ```

2. **The sequence is strictly increasing**

   * Once the sum exceeds `n`, no further sums are valid.

3. **The sum itself must be prime**

   * Not every cumulative sum is prime.

---

## ğŸ§ª Example Walkthrough

### Example 1

```
Input: n = 20

Cumulative sums:
2           â†’ prime
2 + 3 = 5   â†’ prime
2 + 3 + 5 = 10 â†’ not prime
2 + 3 + 5 + 7 = 17 â†’ prime
2 + 3 + 5 + 7 + 11 = 28 â†’ stop (> 20)

Answer = 17
```

### Example 2

```
Input: n = 2
2 = 2 â†’ prime
Answer = 2
```

---

## âœ… Algorithm Strategy

### Step-by-step Approach

1. **Generate all prime numbers up to `n`** using the **Sieve of Eratosthenes**
2. Initialize:

   * `sum = 0`
   * `maxPrime = 0`
3. Loop from `2` to `n`:

   * If the current number is prime:

     * Add it to `sum`
     * If `sum > n`, stop
     * If `sum` is prime â†’ update `maxPrime`
4. Return `maxPrime`

---

## â±ï¸ Time & Space Complexity

| Component             | Complexity           |
| --------------------- | -------------------- |
| Sieve of Eratosthenes | `O(n log log n)`     |
| Single traversal      | `O(n)`               |
| **Total Time**        | **`O(n log log n)`** |
| **Space**             | **`O(n)`**           |

âœ” Efficient for `n â‰¤ 5 Ã— 10^5`

---

## ğŸ§© Reference Java Implementation

```java
import java.util.Arrays;

class Solution {

    public int largestPrime(int n) {

        if (n < 2) return 0;

        boolean[] isPrime = sieve(n);

        int sum = 0;
        int maxPrime = 0;

        for (int i = 2; i <= n; i++) {
            if (isPrime[i]) {
                sum += i;

                if (sum > n) {
                    break;
                }

                if (isPrime[sum]) {
                    maxPrime = sum;
                }
            }
        }

        return maxPrime;
    }

    // Sieve of Eratosthenes
    public static boolean[] sieve(int n) {

        boolean[] isPrime = new boolean[n + 1];
        Arrays.fill(isPrime, true);

        isPrime[0] = false;
        isPrime[1] = false;

        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        return isPrime;
    }
}
```

---

## ğŸ¯ Why This Solution Works

* The **problem constraint â€œstarting from 2â€** guarantees a **single cumulative path**
* Using a sieve avoids repeated expensive prime checks
* Checking `isPrime[sum]` is **O(1)**
* Early termination (`sum > n`) ensures efficiency

---

## âŒ Common Mistakes to Avoid

* âŒ Using sliding window / two pointers
* âŒ Checking all prime subarrays
* âŒ Recomputing primes repeatedly
* âŒ Using trial division for every number

---

## ğŸ§  Interview-Ready Explanation

> â€œBecause the sum must start from prime 2, there is only one valid sequence of consecutive primes. I incrementally compute the cumulative sum and track the largest prime sum within the limit using a sieve for fast primality checks.â€

---

## âœ… Final Notes

* Elegant logic
* Optimal complexity
* Easy to reason and explain
* Perfect for interviews and contests

---

If you want next:

* ğŸ“Š Mathematical proof why only one sequence exists
* ğŸ§ª Visual trace for large `n`
* âš¡ Further micro-optimizations
* ğŸ§© Python / Kotlin version

Just tell me ğŸ‘
