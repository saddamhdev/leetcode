рждрзБржорж┐ ржкрзБрж░рзЛ **Opposite Direction Two Pointers Block** ржЦрзБржм рж╕рзБржирзНржжрж░ржнрж╛ржмрзЗ рж╕рж╛ржЬрж┐рзЯрзЗ ржПржирзЗржЫрзЛред
ржПржЦржи ржЖржорж┐ ржкрзНрж░рждрж┐ржЯрж╛ рж╕ржорж╕рзНржпрж╛рж░ **ржзрж╛рж░ржгрж╛ (concept)** + **ржХрзЗржи opposite-pointer ржХрж╛ржЬ ржХрж░рзЗ** + **ржХржЦржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗ**тАФржПрж╕ржм ржкрж░рж┐рж╖рзНржХрж╛рж░ ржХрж░рзЗ ржжрж┐ржЪрзНржЫрж┐ред

ржПржЧрзБрж▓рзЛ ржЗржирзНржЯрж╛рж░ржнрж┐ржЙрждрзЗ ржорзБржЦрзЗ ржмрж▓рж╛рж░ ржорждрзЛ ржмрзНржпрж╛ржЦрзНржпрж╛ рж╣ржмрзЗред

---

# тнР Opposite Direction Two Pointers тАФ Full Concept Explanation

Opposite Direction ржорж╛ржирзЗ:

```
left тЖТ          тЖР right
```

ржжрзБржЗржжрж┐ржХ ржерзЗржХрзЗ ржнрзЗрждрж░рзЗрж░ ржжрж┐ржХрзЗ рждрзБрж▓ржирж╛/ржЪрж▓рж╛ржлрзЗрж░рж╛ ржХрж░рзЗред

**ржХрзЛржерж╛рзЯ ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯ?**
тЬФ ржпрзЗржЦрж╛ржирзЗ ржжрзБржЗ ржкрзНрж░рж╛ржирзНрждрзЗ ржерж╛ржХрж╛ ржорж╛ржи ржжрж┐рзЯрзЗ рж╕рж┐ржжрзНржзрж╛ржирзНржд ржирж┐рждрзЗ рж╣рзЯ
тЬФ ржпрзЗржЦрж╛ржирзЗ рж╕ржорж╕рзНржпрж╛рж░ рж╕ржорж╛ржзрж╛ржи ржжрзБржЗржжрж┐ржХ ржерзЗржХрзЗ inward move ржХрж░рж▓рзЗ рж╕рж╣ржЬ рж╣рзЯ
тЬФ ржпрзЗржЦрж╛ржирзЗ brute-force O(n┬▓), ржХрж┐ржирзНрждрзБ two pointer ржХрж░рж▓рзЗ O(n) рж╣рзЯ

---

# ЁЯНА Now, your 4 problems with full conceptual explanation:

---

# тЬЕ Problem 1 тАФ Reverse String

```
['h','e','l','l','o']
```

### тнР Why opposite pointers work?

* рж╢рзБрж░рзБ ржерзЗржХрзЗ ржПржХржЯрж╛ ржирж┐рзЯрзЗ
* рж╢рзЗрж╖рзЗ ржерзЗржХрзЗ ржПржХржЯрж╛ ржирж┐рзЯрзЗ
* swap ржХрж░рзЗ ржнрзЗрждрж░рзЗрж░ ржжрж┐ржХрзЗ ржЖрж╕ржмрзЗ
* рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд ржкрзБрж░рзЛ string reverse рж╣рзЯрзЗ ржпрж╛ржмрзЗ

### Visual:

```
h e l l o
тЖС       тЖС
L       R
swap тЖТ o e l l h
```

### Complexity:

* Time: O(n)
* Space: O(1)

тЬФ Perfect use-case for opposite pointers.

---

# тЬЕ Problem 2 тАФ Valid Palindrome

```
A man, a plan, a canal: Panama
```

### тнР Why opposite pointers?

Palindrome ржорж╛ржирзЗ:

> рж╢рзБрж░рзБ ржерзЗржХрзЗ ржЖрж░ рж╢рзЗрж╖рзЗ ржерзЗржХрзЗ ржкрзЬрж▓рзЗ ржПржХржЗ рж╣ржУрзЯрж╛ ржЪрж╛ржЗ

рждрж╛ржЗ naturally two-pointer:

* left рж╢рзБрж░рзБ ржерзЗржХрзЗ
* right рж╢рзЗрж╖рзЗ ржерзЗржХрзЗ
* digit/letter ржирж╛ рж╣рж▓рзЗ skip
* mismatch рж╣рж▓рзЗ false

### Visual:

```
a . m a n
тЖС       тЖС
L       R
match тЖТ move inward
```

тЬФ ржкрзНржпрж╛рж▓рж┐ржиржбрзНрж░рзЛржо ржЪрзЗржХ ржХрж░рж╛рж░ рж╕ржмржЪрзЗрзЯрзЗ efficient methodред

---

# тЬЕ Problem 3 тАФ Two Sum II (Sorted Array)

### тнР Why opposite pointers work?

Because array **is sorted**.

Goal:

```
nums[left] + nums[right] ? target
```

Conditions:

* sum < target тЖТ ржЫрзЛржЯ sum ржЪрж╛ржЗ тЖТ left++
* sum > target тЖТ ржмрзЬ sum ржЪрж╛ржЗ ржирж╛ тЖТ right--
* sum == target тЖТ found

### Visual:

```
[2, 7, 11, 15]
 тЖС           тЖС
 left       right
sum = 17 > 9 тЖТ right--
```

тЬФ Sorted array тЖТ opposite pointers super efficient
тЬФ Complexity: O(n)

---

# тЬЕ Problem 4 тАФ Container With Most Water
ржирж┐рж╢рзНржЪржпрж╝! ржПржЦржи **Container With Most Water** рж╕ржорж╕рзНржпрж╛ржЯрж┐ ржПржХржжржо ржЧржнрзАрж░ржнрж╛ржмрзЗ, рж╕рж╣ржЬ ржнрж╛рж╖рж╛рзЯ,
**Concept + Why Two Pointers + Step-by-step Dry Run + Diagram** рж╕рж╣ ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░ржЫрж┐ред

ржПржЗ ржмрзНржпрж╛ржЦрзНржпрж╛ржЯрж┐ ржЗржирзНржЯрж╛рж░ржнрж┐ржЙ-рж▓рзЗржнрзЗрж▓ ржХрзНрж▓рж┐рзЯрж╛рж░ рж╣ржмрзЗ ЁЯФе

---

# тнР Problem 4: Container With Most Water

Input:

```
height = [1,8,6,2,5,4,8,3,7]
```

Goal:

```
ржжрзБржЗржЯрж┐ рж▓рж╛ржЗржи (i ржПржмржВ j) ржПржоржиржнрж╛ржмрзЗ ржмрзЗржЫрзЗ ржирж┐рждрзЗ рж╣ржмрзЗ ржпрж╛рждрзЗ рждрж╛ржжрзЗрж░ ржоржзрзНржпрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржкрж╛ржирж┐ рж░рж╛ржЦрж╛ ржпрж╛рзЯред
```

---

# ЁЯза ржорзВрж▓ ржзрж╛рж░ржгрж╛ (Very Important)

ржжрзБржЯрж┐ рж▓рж╛ржЗржи ржжрж┐рзЯрзЗ Container рждрзИрж░рж┐ рж╣рзЯ:

* ржЙржЪрзНржЪрждрж╛ = min( height[left], height[right] )
* ржкрзНрж░рж╕рзНрже (width) = right - left

рждрж╛рж╣рж▓рзЗ ржкрж╛ржирж┐ ржзрж╛рж░ржг ржХрзНрж╖ржорждрж╛:

```
area = height ├Ч width
area = min(height[left], height[right]) ├Ч (right - left)
```

---

# тнР ржХрзЗржи Brute Force ржирзЯ?

Brute force:

```
ржкрзНрж░рждрж┐ржЯрж┐ pair ржирж┐рзЯрзЗ area ржмрзЗрж░ ржХрж░рж╛ тЖТ O(n┬▓)
```

ржХрж┐ржирзНрждрзБ Two Pointer ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ:

```
O(n) рждрзЗ ржХрж╛ржЬ рж╢рзЗрж╖! (Most optimal)
```

---

# тнР ржХрзЗржи Opposite Direction Two Pointer?

ржХрж╛рж░ржг:

1я╕ПтГг Area = min(leftHeight, rightHeight) ├Ч width
2я╕ПтГг Width ржХржорж╛рждрзЗ ржерж╛ржХрж╛рзЯ height ржмрзЬ рж╣рж▓рзЗ area ржмрзЬ рж╣рждрзЗ ржкрж╛рж░рзЗ
3я╕ПтГг ржпрзЗ ржкрзЯрзЗржирзНржЯрж╛рж░рзЗрж░ height ржХржо тЖТ рж╕рзЗ limitation

ЁЯСЙ рждрж╛ржЗ **ржЫрзЛржЯ heightтАУржПрж░ pointer рж╕рж░рж╛рждрзЗ рж╣ржмрзЗ**ред

---

# тнР Algorithm Summary (2 Lines):

* area ржмрзЗрж░ ржХрж░рзЛ
* height[left] < height[right] рж╣рж▓рзЗ тЖТ left++
* ржирж╛ рж╣рж▓рзЗ тЖТ right--

ржПржЯрж╛ржЗ ржкрзБрж░рзЛ рж▓ржЬрж┐ржХ ЁЯФе

---

# тнР Java Code (simple & optimal)

```java
public int maxArea(int[] height) {
    int left = 0;
    int right = height.length - 1;
    int max = 0;

    while (left < right) {
        int h = Math.min(height[left], height[right]);
        int w = right - left;
        int area = h * w;

        max = Math.max(max, area);

        if (height[left] < height[right]) left++;
        else right--;
    }

    return max;
}
```

---

# ЁЯУМ ржПржЦржи Step-by-Step Dry Run (ржмрзБржЭрж▓рзЗ ржХржЦржирзЛ ржнрзБрж▓ржмрзЗ ржирж╛)

Given:

```
height = [1,8,6,2,5,4,8,3,7]
```

рж╢рзБрж░рзБрждрзЗ:

```
left = 0  тЖТ height = 1
right = 8 тЖТ height = 7

area = min(1,7) ├Ч (8-0) = 1 ├Ч 8 = 8
max = 8
small height = 1 тЖТ left++
```

---

### Iteration 2:

```
left = 1 тЖТ height = 8
right = 8 тЖТ height = 7

area = min(8,7) ├Ч (8-1) = 7 ├Ч 7 = 49
max = 49  тЖР new max
small height = 7 тЖТ right--
```

---

### Iteration 3:

```
left = 1 (8)
right = 7 (3)

area = min(8,3) ├Ч 6 = 3 ├Ч 6 = 18
max = 49
small = 3 тЖТ right--
```

---

### Iteration 4:

```
left = 1 (8)
right = 6 (8)

area = min(8,8) ├Ч 5 = 8 ├Ч 5 = 40
max = 49
small = equal тЖТ right--
```

---

### Iteration 5:

```
left = 1 (8)
right = 5 (4)

area = 4 ├Ч 4 = 16
max = 49
small = 4 тЖТ right--
```

---

### Iteration 6:

```
left = 1 (8)
right = 4 (5)

area = 5 ├Ч 3 = 15
max = 49
small = 5 тЖТ right--
```

---

### Iteration 7:

```
left = 1 (8)
right = 3 (2)

area = 2 ├Ч 2 = 4
max = 49
small = 2 тЖТ right--
```

---

### Iteration 8:

```
left = 1 (8)
right = 2 (6)

area = 6 ├Ч 1 = 6
max = 49
small = 6 тЖТ right--
```

---

### Iteration 9:

```
left = 1 (8)
right = 1 тЖТ Stop (left == right)
```

Final Answer:

```
max = 49  тЖР BEST possible
```

---

# тнР ржПржЦржи Diagram ржП ржжрзЗржЦрж╛ржЗ (Super Clear)

```
Index:  0 1 2 3 4 5 6 7 8
Height: 1 8 6 2 5 4 8 3 7
         тЖС               тЖС
       left=0         right=8
       
Area = min(1,7) ├Ч 8 = 8
тЖТ left moves (because 1 < 7)

--------------------------------

         0 1 2 3 4 5 6 7 8
Height:  1 8 6 2 5 4 8 3 7
           тЖС             тЖС
         left=1       right=8

Area = min(8,7) ├Ч 7 = 49  тЖР MAX
тЖТ right moves (because 7 < 8)
```

ржПржнрж╛ржмрзЗ pointer inward рж╣ржмрзЗред

---

# тнР Why does this always give correct answer?

ржХрж╛рж░ржг:

* width ржХржоржЫрзЗ ржзрзАрж░рзЗ ржзрзАрж░рзЗ
* height ржмрж╛рзЬрж╛ржирзЛрж░ рж╕рзБржпрзЛржЧ рж╢рзБржзрзБ ржЫрзЛржЯ height pointer ржП
* рждрж╛ржЗ ржЫрзЛржЯ height pointer рж╕рж░рж╛ржирзЛ рж╕ржмржЪрзЗржпрж╝рзЗ optimal

Mathematical proof ржЖржЫрзЗ тАФ two pointer solution **guarantees maximum area** (optimal solution).

---

# тнР Interview-Level Explanation (Short & Clear)

> ржЖржорж░рж╛ ржжрзБржЯрзЛ pointer ржжрж┐рзЯрзЗ arrayтАУржПрж░ ржжрзБржЗ ржкрзНрж░рж╛ржирзНрждрзЗ height ржирзЗржЗред
> ржкрзНрж░рж╕рзНрже рж╣рж▓рзЛ `right-left` ржПржмржВ ржЙржЪрзНржЪрждрж╛ рж╣рж▓рзЛ `min(h[left], h[right])`ред
> ржпрзЗ height ржЫрзЛржЯ, рж╕рзЗржЗ pointer limitation ржХрж░рзЗ, рждрж╛ржЗ рждрж╛ржХрзЗ inward ржЖржирж╛ рж╣рзЯред
> ржПрждрзЗ width ржХржорж▓рзЗржУ height ржмрж╛рзЬрж╛рж░ рж╕рзБржпрзЛржЧ ржерж╛ржХрзЗред
> O(n) рж╕ржорзЯрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ possible container ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯред

---

ржпржжрж┐ ржЪрж╛ржУ, ржЖржорж┐ ржПржЦржи
тЬЕ **ASCII step-by-step animation**,
ржмрж╛
тЬЕ **ржЖрж░рзЛ рзйржЯрж╛ similar two-pointer problem (hard version)**
ржжрж┐рзЯрзЗ ржжрж┐рждрзЗ ржкрж╛рж░рж┐ред

ржХрзЛржиржЯрж╛ ржЪрж╛ржУ?
