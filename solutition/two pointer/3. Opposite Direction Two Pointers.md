# 1️⃣ **Opposite Direction Two Pointers**

ব্যবহার: যতক্ষণ দুই দিক থেকে তুলনা করতে হবে

### উদাহরণ সমস্যা:

* Reverse String
* Valid Palindrome
* Container With Most Water
* Two Sum II (sorted)
* Remove duplicates (variant)

### Java টেমপ্লেট:

```java
int left = 0;
int right = arr.length - 1;

while (left < right) {
    // কাজ
    left++;
    right--;
}
```

---

# ✅ **Problem 1: Reverse String**

```
Input: ['h','e','l','l','o']
Output: ['o','l','l','e','h']
```

### Java:

```java
public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;

    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;

        left++;
        right--;
    }
}
```

---

# ✅ **Problem 2: Valid Palindrome**

```
Input: "A man, a plan, a canal: Panama"
Output: true
```

### Java:

```java
public boolean isPalindrome(String s) {
    s = s.toLowerCase();
    int left = 0, right = s.length() - 1;

    while (left < right) {
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) left++;
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) right--;

        if (s.charAt(left) != s.charAt(right)) return false;

        left++;
        right--;
    }

    return true;
}
```

---

# ✅ **Problem 3: Two Sum II (Sorted Array)**

```
Input: [2,7,11,15], target = 9
Output: [1,2]
```

### Java:

```java
public int[] twoSum(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int sum = nums[left] + nums[right];

        if (sum == target) return new int[]{left+1, right+1};
        else if (sum < target) left++;
        else right--;
    }
    return new int[]{};
}
```

---

# ✅ **Problem 4: Container With Most Water**

### Java:

```java
public int maxArea(int[] height) {
    int left = 0, right = height.length - 1;
    int max = 0;

    while (left < right) {
        int area = Math.min(height[left], height[right]) * (right - left);
        max = Math.max(max, area);

        if (height[left] < height[right]) left++;
        else right--;
    }
    return max;
}
```

---

