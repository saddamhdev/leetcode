Here is the **simplest explanation + step-by-step dry run** for
**LeetCode 876 â€“ Middle of the Linked List**
(using **slowâ€“fast pointer** method).

---

# âœ… Problem

Given the head of a linked list, return the **middle node**.
If there are **two** middle nodes (even length), return the **second** one.

---

# âœ… The Trick: Slow & Fast Pointers

* `slow` â†’ moves **1 step**
* `fast` â†’ moves **2 steps**

When `fast` reaches **end**,
`slow` will be at the **middle**.

---

# âœ… Code (Most Popular Solution)

```java
public ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;         // slow moves 1 step
        fast = fast.next.next;    // fast moves 2 steps
    }
    
    return slow;
}
```

---

# âœ… Step-by-Step Example

Suppose the linked list is:

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
```

This is **odd length** (5).
Expected middle = **3**

---

## ðŸ”¥ Initial State

```
slow = 1
fast = 1
```

---

## ðŸ”¥ Iteration 1

* `slow = 2`
* `fast = 3`

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
     S         F
```

---

## ðŸ”¥ Iteration 2

* `slow = 3`
* `fast = 5`

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
          S         F
```

---

## ðŸ”¥ Iteration 3

`fast.next == null`, loop stops.

Return `slow` â‡’ **3** ðŸŽ¯

---

# âœ… Even-Length Example

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
```

Even length = 6
Two middles = `3` and `4`
According to problem â†’ return **4**

---

## ðŸ”¥ Walkthrough

### Initial

```
slow = 1
fast = 1
```

---

### Iteration 1

* slow = 2
* fast = 3

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
     S         F
```

---

### Iteration 2

* slow = 3
* fast = 5

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
          S         F
```

---

### Iteration 3

* slow = 4
* fast = null (because 5 â†’ 6 â†’ null)

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
               S        F=null
```

Loop ends, return `slow` â‡’ **4** ðŸŽ¯

Exactly what the problem wants.

---

# ðŸ”¥ Why It Works? (Intuition)

* `fast` moves **twice as fast**
* When `fast` reaches the end
* `slow` has reached **middle** because:

  ```
  slow travelled = fast travelled / 2
  ```

No need to count length.
No need for extra passes.

---

# âœ… Final Summary

| List Length | Middle Returned   |
| ----------- | ----------------- |
| Odd (5)     | 3                 |
| Even (6)    | 4 (second middle) |

Algorithm is **O(n)** time, **O(1)** space.

---

If you want, I can also explain:

âœ… Why slow-fast pointers always work
âœ… Draw a diagram
âœ… Provide a recursive or two-pass solution
âœ… Create practice problems after this one
