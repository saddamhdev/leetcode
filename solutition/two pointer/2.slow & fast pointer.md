‡¶¶‡¶æ‡¶∞‡ßÅ‡¶£ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® üòÑ
‡¶ö‡¶≤ **slow & fast pointer** ‡¶¶‡ßÅ‡¶ü‡ßã ‡¶ï‡ßç‡¶≤‡¶ø‡ßü‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶ø ‡¶¶‡ßÅ‚Äô‡¶ü‡¶æ ‡¶è‡¶ï‡ßç‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡¶≤ ‡¶¶‡¶ø‡ßü‡ßá,
**‡¶è‡¶ï‡¶ü‡¶æ array‚Äìbased** ‡¶Ü‡¶∞ **‡¶è‡¶ï‡¶ü‡¶æ linked list‚Äìbased**,
‡¶Ü‡¶∞ ‡¶¶‡ßÅ‡¶ü‡ßã‡¶á **step by step** ‡¶ü‡ßç‡¶∞‡ßá‡¶∏ ‡¶ï‡¶∞‡¶¨‡•§

---

## üßÆ Example 1: Remove Duplicates from Sorted Array

**Problem:**
`nums = [1, 1, 2, 2, 3, 4, 4]`
‡¶°‡ßÅ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶ü ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡ßü‡ßá ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá ‡¶Ü‡¶®‡¶§‡ßá ‡¶π‡¶¨‡ßá (in-place), ‡¶Ü‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ï‡¶∞‡¶¨‡ßá‡•§

### üîë Idea (Slow & Fast)

* `fast` ‚Üí ‡¶™‡ßÅ‡¶∞‡ßã array ‡¶∏‡ßç‡¶ï‡ßç‡¶Ø‡¶æ‡¶® ‡¶ï‡¶∞‡¶¨‡ßá
* `slow` ‚Üí ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶Æ‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã "‡¶ï‡ßã‡¶•‡¶æ‡ßü ‡¶∞‡¶æ‡¶ñ‡¶¨" ‡¶∏‡ßá‡¶ü‡¶æ ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡¶¨‡ßá

**Rule:**

> ‡¶Ø‡¶ñ‡¶®‡¶á `nums[fast] != nums[slow - 1]`, ‡¶§‡¶ñ‡¶®
> `nums[slow] = nums[fast]`
> ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ `slow++`

‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶∏‡¶π‡¶ú ‡¶≠‡¶æ‡¶∞‡ßç‡¶∏‡¶® ‡¶®‡ßá‡¶¨:

```java
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;

    int slow = 1; // slow ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ
    for (int fast = 1; fast < nums.length; fast++) {
        if (nums[fast] != nums[fast - 1]) { // ‡¶®‡¶§‡ßÅ‡¶® ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶™‡ßá‡¶≤‡¶æ‡¶Æ
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow; // ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ
}
```

### ‚ñ∂ Step‚Äìby‚ÄìStep Trace

‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá:

```text
nums = [1, 1, 2, 2, 3, 4, 4]
         ^
        fast
         ^
        slow (1 ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ)
```

‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ß‡¶∞‡ßá ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡¶ø `nums[0]` ‡¶∏‡¶¨‡¶∏‡¶Æ‡ßü ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§

---

#### üîπ Iteration 1

`fast = 1`, `slow = 1`

* `nums[fast] = nums[1] = 1`
* `nums[fast - 1] = nums[0] = 1`
* ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ: `1 == 1` ‚Üí **‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶®‡¶æ**, ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶∞‡¶¨ ‡¶®‡¶æ

Array ‡¶è‡¶ï‡¶á:

```text
nums = [1, 1, 2, 2, 3, 4, 4]
          ‚Üë
         fast
         ‚Üë
        slow
```

---

#### üîπ Iteration 2

`fast = 2`, `slow = 1`

* `nums[fast] = nums[2] = 2`
* `nums[fast - 1] = nums[1] = 1`
* ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ: `2 != 1` ‚Üí **‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶Æ‡¶æ‡¶® ‡¶™‡ßá‡¶≤‡¶æ‡¶Æ**

Action:

```text
nums[slow] = nums[fast]  ‚áí nums[1] = 2
slow++  ‚áí slow = 2
```

Now array:

```text
nums = [1, 2, 2, 2, 3, 4, 4]
             ‚Üë
            fast(2)
          ‚Üë
         slow(2)
```

---

#### üîπ Iteration 3

`fast = 3`, `slow = 2`

* `nums[fast] = nums[3] = 2`
* `nums[fast - 1] = nums[2] = 2`
* `2 == 2` ‚Üí ‡¶°‡ßÅ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶ü, ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶∞‡¶¨ ‡¶®‡¶æ

---

#### üîπ Iteration 4

`fast = 4`, `slow = 2`

* `nums[fast] = nums[4] = 3`
* `nums[fast - 1] = nums[3] = 2`
* `3 != 2` ‚Üí ‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡¶æ‡¶®

Action:

```text
nums[slow] = nums[fast] ‚áí nums[2] = 3
slow++ ‚áí slow = 3
```

Array:

```text
nums = [1, 2, 3, 2, 3, 4, 4]
                ‚Üë fast(4)
             ‚Üë slow(3)
```

---

#### üîπ Iteration 5

`fast = 5`, `slow = 3`

* `nums[fast] = nums[5] = 4`
* `nums[fast - 1] = nums[4] = 3`
* `4 != 3` ‚Üí ‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡¶æ‡¶®

Action:

```text
nums[slow] = nums[fast] ‚áí nums[3] = 4
slow++ ‚áí slow = 4
```

Array:

```text
nums = [1, 2, 3, 4, 3, 4, 4]
                   ‚Üë fast(5)
                ‚Üë slow(4)
```

---

#### üîπ Iteration 6

`fast = 6`, `slow = 4`

* `nums[fast] = nums[6] = 4`
* `nums[fast - 1] = nums[5] = 4`
* `4 == 4` ‚Üí ‡¶°‡ßÅ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶ü, ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶∞‡¶¨ ‡¶®‡¶æ

Loop ‡¶∂‡ßá‡¶∑ ‚úÖ

### üîö Final Result

* `slow = 4` ‚áí **‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ = 4**
* ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡ß™‡¶ü‡¶æ ‡¶™‡¶ú‡¶ø‡¶∂‡¶®‡ßá ‡¶•‡¶æ‡¶ï‡¶¨‡ßá: `[1, 2, 3, 4]`

```text
nums = [1, 2, 3, 4, 3, 4, 4]
         ‚Üë  ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶Ö‡¶Ç‡¶∂ (index 0..3)
```

**‡¶è‡¶ñ‡¶æ‡¶®‡ßá:**
`fast` = ‡¶™‡ßÅ‡¶∞‡ßã ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶ò‡ßÅ‡¶∞‡ßá
`slow` = ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ "‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ"

‡¶è‡¶ü‡¶æ‡¶á slow‚Äìfast pointer-‡¶è‡¶∞ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡¶ø‡¶ï ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡•§

---

‡¶ö‡¶Æ‡ßé‡¶ï‡¶æ‡¶∞! ‡¶è‡¶ñ‡¶® ‡¶Ü‡¶Æ‡¶∞‡¶æ **Move Zeroes** ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ **Slow & Fast Pointer** ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶∂‡¶ø‡¶ñ‡¶¨ ‚Äî
**Java ‡¶ï‡ßã‡¶° + Step-by-step diagram** ‡¶∏‡¶π‡•§

---

# 2 ‚≠ê Problem: Move Zeroes

Input:

```
[0, 1, 0, 3, 12]
```

Output:

```
[1, 3, 12, 0, 0]
```

‚úî ‡¶∏‡¶¨ 0 ‡¶ï‡ßá ‡¶∂‡ßá‡¶∑‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá
‚úî non-zero ‡¶Æ‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá
‚úî ‡¶á‡¶®‚Äì‡¶™‡ßç‡¶≤‡ßá‡¶∏ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá (‡¶®‡¶§‡ßÅ‡¶® ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶®‡¶Ø‡¶º)

---

# ‚≠ê Slow & Fast Pointer Logic

* **fast pointer** ‚Üí ‡¶™‡ßÅ‡¶∞‡ßã ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶∏‡ßç‡¶ï‡ßç‡¶Ø‡¶æ‡¶® ‡¶ï‡¶∞‡¶¨‡ßá
* **slow pointer** ‚Üí ‡¶ï‡ßã‡¶•‡¶æ‡¶Ø‡¶º non-zero ‡¶¨‡¶∏‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá ‡¶∏‡ßá‡¶á "‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶™‡¶ú‡¶ø‡¶∂‡¶®"

### üîë Rule:

‡¶Ø‡¶ñ‡¶®‡¶á fast ‡¶ï‡ßã‡¶®‡ßã non-zero ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶¨‡ßá:

```
nums[slow] = nums[fast]
slow++
```

‡¶∂‡ßá‡¶∑‡ßá slow ‡¶è‡¶∞ ‡¶™‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨ ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ‡¶Ø‡¶º 0 ‡¶¨‡¶∏‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡ßá‡¶¨‡ßá‡•§

‡¶è‡¶ü‡¶æ‡¶á ‡¶Æ‡ßÇ‡¶≤ ‡¶≤‡¶ú‡¶ø‡¶ï‡•§

---

# ‚≠ê Java Solution (Slow & Fast Pointer)

```java
public void moveZeroes(int[] nums) {
    int slow = 0;  // next position to write non-zero

    // Step 1: Move all non-zero elements to the front
    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != 0) {
            nums[slow] = nums[fast];
            slow++;
        }
    }

    // Step 2: Fill remaining positions with 0
    while (slow < nums.length) {
        nums[slow] = 0;
        slow++;
    }
}
```

---

# ‚≠ê Step-by-Step Dry Run

Input:

```
[0, 1, 0, 3, 12]
```

### Initial:

```
slow = 0
fast scans from left to right
```

---

## ‚ñ∂ Step 1: fast = 0

```
nums[0] = 0  ‚Üí ignore (zero)
```

Array stays same.

---

## ‚ñ∂ Step 2: fast = 1

```
nums[1] = 1 (non-zero)
nums[slow] = nums[fast] ‚Üí nums[0] = 1
slow++
```

Array:

```
[1, 1, 0, 3, 12]
 ^
slow = 1
```

---

## ‚ñ∂ Step 3: fast = 2

```
nums[2] = 0 ‚Üí ignore
```

---

## ‚ñ∂ Step 4: fast = 3

```
nums[3] = 3 (non-zero)
nums[slow] = nums[fast] ‚Üí nums[1] = 3
slow++
```

Array:

```
[1, 3, 0, 3, 12]
    ^
    slow = 2
```

---

## ‚ñ∂ Step 5: fast = 4

```
nums[4] = 12 (non-zero)
nums[slow] = nums[fast] ‚Üí nums[2] = 12
slow++
```

Array:

```
[1, 3, 12, 3, 12]
        ^
        slow = 3
```

---

# Step 2: Fill remaining with zero

slow = 3, so:

```
nums[3] = 0
nums[4] = 0
```

Final:

```
[1, 3, 12, 0, 0]
```

‚úî Done üéâ

---

# ‚≠ê Visualization (Diagram)

```
Initial:
[0, 1, 0, 3, 12]
 ^ 
 slow=0, fast=0

After fast=1:
[1, 1, 0, 3, 12]
    ^ 
   slow=1

After fast=3:
[1, 3, 0, 3, 12]
       ^
      slow=2

After fast=4:
[1, 3, 12, 3, 12]
          ^
         slow=3

Fill zeros:
[1, 3, 12, 0, 0]
```

---

# ‚≠ê Summary

‚úì fast ‚Üí ‡¶∏‡ßç‡¶ï‡ßç‡¶Ø‡¶æ‡¶® ‡¶ï‡¶∞‡ßá non-zero ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶Ü‡¶®‡ßá
‚úì slow ‚Üí non-zero ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶™‡¶ú‡¶ø‡¶∂‡¶®
‚úì ‡¶∂‡ßá‡¶∑‡ßá slow ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶æ‡¶ï‡¶ø ‡¶∏‡¶¨ ‡¶™‡¶ú‡¶ø‡¶∂‡¶®‡ßá 0

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## üî• ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶® "Move Zeroes" ‡¶è‡¶∞

* Opposite pointer version (swap based)
* Sliding window analogy
* Java cheat sheet
  ‡¶è‡¶∏‡¶¨‡¶ì ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡•§




## üå≥ Example 3: Linked List Cycle Detection

(‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶Ü‡¶∞‡ßá‡¶ï‡¶ü‡¶æ step‚Äìby‚Äìstep)

List: `3 ‚Üí 2 ‚Üí 0 ‚Üí -4`
‡¶è‡¶¨‡¶Ç `-4` ‡¶Ü‡¶¨‡¶æ‡¶∞ `2`-‡¶§‡ßá ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶õ‡ßá (cycle ‡¶Ü‡¶õ‡ßá)

```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;         // ‡ßß step
        fast = fast.next.next;    // ‡ß® step

        if (slow == fast) return true;
    }
    return false;
}
```

### ‚ñ∂ Step‚Äìby‚ÄìStep Positions

‡¶ß‡¶∞‡ßã nodes: `A(3) ‚Üí B(2) ‚Üí C(0) ‚Üí D(-4) ‚Üí (back to B)`

| Step | slow | fast |                           |
| ---- | ---- | ---- | ------------------------- |
| 0    | A    | A    |                           |
| 1    | B    | C    |                           |
| 2    | C    | B    |                           |
| 3    | D    | D    | ‚Üê **‡¶Æ‡¶ø‡¶ü ‡¶ï‡¶∞‡¶≤ = cycle ‡¶Ü‡¶õ‡ßá** |

‡¶è‡¶ñ‡¶æ‡¶®‡ßá fast ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶¨‡¶æ‡¶∞ ‡¶¶‡ßÅ‡¶á ‡¶ß‡¶æ‡¶™ ‡¶è‡¶ó‡ßã‡ßü, ‡¶§‡¶æ‡¶á ‡¶∏‡ßá ‡¶Ø‡¶¶‡¶ø circle‚Äì‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá ‡¶ò‡ßÅ‡¶∞‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡ßá, ‡¶è‡¶ï ‡¶∏‡¶Æ‡ßü slow‚Äì‡¶è‡¶∞ ‡¶∏‡¶ô‡ßç‡¶ó‡ßá ‡¶Æ‡¶ø‡¶≤‡¶¨‡ßá‡¶á‡•§

---

## üß† ‡¶Æ‡¶æ‡¶•‡¶æ‡ßü ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ï‡¶•‡¶æ

* **Opposite direction** ‚Üí `left` & `right` ‡¶è‡¶ï‡ßá ‡¶Ö‡¶™‡¶∞‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá ‡¶Ü‡¶∏‡ßá
* **Slow & fast** ‚Üí ‡¶¶‡ßÅ‚Äô‡¶ú‡¶®‡ßá‡¶á ‡¶è‡¶ï‡¶á ‡¶¶‡¶ø‡¶ï‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶æ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ

  * fast ‚Üí search / detect
  * slow ‚Üí settle / store / follow
* Array‚Äìbased problem ‡¶è slow‚Äìfast ‡¶¶‡¶ø‡ßü‡ßá:

  * remove duplicates
  * move zeroes
* Linked list‚Äìbased problem ‡¶è slow‚Äìfast ‡¶¶‡¶ø‡ßü‡ßá:

  * cycle detect
  * middle of list

---

‡¶Ø‡¶¶‡¶ø ‡¶ö‡¶æ‡¶ì,
üëâ ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶® **‡¶è‡¶ï‡¶ü‡¶æ ‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡¶ø‡¶∏ ‡¶™‡ßç‡¶∞‡¶¨‡¶≤‡ßá‡¶Æ ‡¶¶‡¶ø‡¶á**, ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶Ø‡ßá ‡¶≤‡¶ú‡¶ø‡¶ï ‡¶¨‡¶≤‡¶¨‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶¶‡ßá‡¶ñ‡ßá ‡¶Ü‡¶Æ‡¶ø Java ‡¶ï‡ßã‡¶° ‡¶¨‡¶æ‡¶®‡¶ø‡ßü‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßã ‚Äî ‡¶è‡¶ï‡¶¶‡¶Æ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤‡ßá‡•§
