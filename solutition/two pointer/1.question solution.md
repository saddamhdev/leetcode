‡¶¶‡¶æ‡¶∞‡ßÅ‡¶£! ‡¶è‡¶ñ‡¶® ‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá **Java ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï Two Pointers ‡¶´‡ßÅ‡¶≤ ‡¶ï‡ßã‡¶∞‡ßç‡¶∏** ‡¶¶‡¶ø‡¶ö‡ßç‡¶õ‡¶ø‚Äî
‡¶è‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡¶¨‡ßá:

### ‚úî Two Pointers ‡¶ï‡ßÄ

### ‚úî ‡ß© ‡¶ß‡¶∞‡¶®‡ßá‡¶∞ Two Pointer ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ

### ‚úî ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Java ‡¶ï‡ßã‡¶°

### ‚úî ‡ßß‡ß¶‡¶ü‡¶ø ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â-‡¶´‡ßã‡¶ï‡¶æ‡¶∏‡¶° ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ

### ‚úî ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®-‡¶ü‡ßá‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ü

### ‚úî ‡¶ï‡ßã‡¶® ‡¶™‡¶∞‡¶ø‡¶∏‡ßç‡¶•‡¶ø‡¶§‡¶ø‡¶§‡ßá ‡¶ï‡ßã‡¶® Two Pointer ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá

‡¶è‡¶ü‡¶æ‡¶á ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø **Two Pointer Mastery Pack (Java Edition)**

---

# ‚≠ê Two Pointers ‚Äî ‡ß© ‡¶ß‡¶∞‡¶®‡ßá‡¶∞ ‡¶ï‡ßå‡¶∂‡¶≤ (Java + Diagram)

---

# 1Ô∏è‚É£ **Opposite Direction Two Pointers**

‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞: ‡¶Ø‡¶§‡¶ï‡ßç‡¶∑‡¶£ ‡¶¶‡ßÅ‡¶á ‡¶¶‡¶ø‡¶ï ‡¶•‡ßá‡¶ï‡ßá ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá

### ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ:

* Reverse String
* Valid Palindrome
* Container With Most Water
* Two Sum II (sorted)
* Remove duplicates (variant)

### Java ‡¶ü‡ßá‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ü:

```java
int left = 0;
int right = arr.length - 1;

while (left < right) {
    // ‡¶ï‡¶æ‡¶ú
    left++;
    right--;
}
```

---

# 2Ô∏è‚É£ **Same Direction (Slow & Fast Pointers)**

‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞:

* Linked List cycle
* Middle of Linked List
* Remove duplicates from sorted array
* Detect loop

### Java ‡¶ü‡ßá‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ü:

```java
int slow = 0;
int fast = 0;

while (fast < arr.length && fast + 1 < arr.length) {
    slow++;
    fast += 2;
}
```

Linked List Version:

```java
ListNode slow = head;
ListNode fast = head;

while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
```

---

# 3Ô∏è‚É£ **Sliding Window (Two Pointers Expanding/Contracting)**

‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞:

* Longest Substring Without Repeating Characters
* Minimum Window Substring
* Subarray sum / K
* Fixed size window

### Java ‡¶ü‡ßá‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ü:

```java
int left = 0;

for (int right = 0; right < s.length(); right++) {
    // window expand

    while (/* condition to shrink */) {
        left++;
    }
}
```

---

# üî• ‡¶è‡¶ñ‡¶® ‡ßß‡ß¶‡¶ü‡¶ø ‡¶ú‡¶®‡¶™‡ßç‡¶∞‡¶ø‡¶Ø‡¶º Two Pointer ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ + Java ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

---

# ‚úÖ **Problem 1: Reverse String**

```
Input: ['h','e','l','l','o']
Output: ['o','l','l','e','h']
```

### Java:

```java
public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;

    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;

        left++;
        right--;
    }
}
```

---

# ‚úÖ **Problem 2: Valid Palindrome**

```
Input: "A man, a plan, a canal: Panama"
Output: true
```

### Java:

```java
public boolean isPalindrome(String s) {
    s = s.toLowerCase();
    int left = 0, right = s.length() - 1;

    while (left < right) {
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) left++;
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) right--;

        if (s.charAt(left) != s.charAt(right)) return false;

        left++;
        right--;
    }

    return true;
}
```

---

# ‚úÖ **Problem 3: Two Sum II (Sorted Array)**

```
Input: [2,7,11,15], target = 9
Output: [1,2]
```

### Java:

```java
public int[] twoSum(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int sum = nums[left] + nums[right];

        if (sum == target) return new int[]{left+1, right+1};
        else if (sum < target) left++;
        else right--;
    }
    return new int[]{};
}
```

---

# ‚úÖ **Problem 4: Container With Most Water**

### Java:

```java
public int maxArea(int[] height) {
    int left = 0, right = height.length - 1;
    int max = 0;

    while (left < right) {
        int area = Math.min(height[left], height[right]) * (right - left);
        max = Math.max(max, area);

        if (height[left] < height[right]) left++;
        else right--;
    }
    return max;
}
```

---

# ‚úÖ **Problem 5: Remove Duplicates from Sorted Array**

### Java (Slow & Fast):

```java
public int removeDuplicates(int[] nums) {
    int slow = 1;

    for (int fast = 1; fast < nums.length; fast++) {
        if (nums[fast] != nums[fast - 1]) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

---

# ‚úÖ **Problem 6: Longest Substring Without Repeating Characters**

(Sliding Window)

### Java:

```java
public int lengthOfLongestSubstring(String s) {
    int[] map = new int[128];
    int left = 0, max = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        map[c]++;

        while (map[c] > 1) {
            map[s.charAt(left)]--;
            left++;
        }

        max = Math.max(max, right - left + 1);
    }

    return max;
}
```

---

# ‚úÖ **Problem 7: Minimum Size Subarray Sum**

### Java:

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0, sum = 0, min = Integer.MAX_VALUE;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];

        while (sum >= target) {
            min = Math.min(min, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
```

---

# ‚úÖ **Problem 8: Move Zeroes**

### Java:

```java
public void moveZeroes(int[] nums) {
    int slow = 0;

    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != 0) {
            int temp = nums[slow];
            nums[slow] = nums[fast];
            nums[fast] = temp;

            slow++;
        }
    }
}
```

---

# ‚úÖ **Problem 9: Middle of Linked List**

### Java:

```java
public ListNode middleNode(ListNode head) {
    ListNode slow = head, fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}
```

---

# ‚úÖ **Problem 10: Linked List Cycle**

### Java:

```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) return true;
    }
    return false;
}
```

---

# üß† **Two Pointers Quick Summary (For Interview Memory)**

| Problem Category           | Two Pointer ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ |
| -------------------------- | ------------------- |
| Reverse / Palindrome       | Left‚ÄìRight          |
| Container With Most Water  | Left‚ÄìRight          |
| Pair Sum in sorted arrays  | Left‚ÄìRight          |
| Remove Duplicates          | Slow‚ÄìFast           |
| Move Zeroes                | Slow‚ÄìFast           |
| Linked List Cycle          | Slow‚ÄìFast           |
| Middle of Linked List      | Slow‚ÄìFast           |
| Longest Substring (unique) | Sliding Window      |
| Minimum Window             | Sliding Window      |
| Subarray Sum (positive)    | Sliding Window      |

---

# üéØ ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ï‡¶ø Two Pointers-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø

### ‚úî ‡ß®‡ß¶‡¶ü‡¶ø ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ +

### ‚úî Difficulty-wise Roadmap +

### ‚úî Java ‡¶ü‡ßá‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ü Cheat Sheet

‡¶ö‡¶æ‡¶ì?

‡¶¨‡¶≤: **"‡¶π‡ßç‡¶Ø‡¶æ‡¶Å, Two Pointer Practice List ‡¶¶‡¶æ‡¶ì"**
