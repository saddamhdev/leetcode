Hereâ€™s a **clean, interview-ready Time & Space Complexity cheat sheet** for the **most frequently asked LeetCode problems** you listed.
(Exactly what interviewers expect you to say.)

---

# ðŸ“Œ Arrays

| Problem                   | Time     | Space    | Notes                |
| ------------------------- | -------- | -------- | -------------------- |
| Two Sum                   | **O(n)** | **O(n)** | HashMap lookup       |
| Best Time Buy/Sell Stock  | **O(n)** | **O(1)** | Track min price      |
| Maximum Subarray          | **O(n)** | **O(1)** | Kadaneâ€™s Algorithm   |
| Container With Most Water | **O(n)** | **O(1)** | Two pointers         |
| Rotate Array              | **O(n)** | **O(1)** | Reverse array method |

---

# ðŸ“Œ Strings

| Problem                             | Time             | Space      | Notes                          |
| ----------------------------------- | ---------------- | ---------- | ------------------------------ |
| Reverse String                      | **O(n)**         | **O(1)**   | In-place                       |
| Valid Palindrome                    | **O(n)**         | **O(1)**   | Two pointers                   |
| Longest Substring Without Repeating | **O(n)**         | **O(k)**   | Sliding window (`k` = charset) |
| Group Anagrams                      | **O(nÂ·k log k)** | **O(nÂ·k)** | `k` = word length              |
| Longest Palindromic Substring       | **O(nÂ²)**        | **O(1)**   | Expand from center             |

---

# ðŸ“Œ Linked List

| Problem                   | Time         | Space    | Notes              |
| ------------------------- | ------------ | -------- | ------------------ |
| Reverse Linked List       | **O(n)**     | **O(1)** | Iterative          |
| Merge Two Sorted Lists    | **O(n + m)** | **O(1)** | Dummy node         |
| Remove Nth Node From End  | **O(n)**     | **O(1)** | Fastâ€“slow pointers |
| Linked List Cycle         | **O(n)**     | **O(1)** | Floydâ€™s cycle      |
| Intersection of Two Lists | **O(n + m)** | **O(1)** | Pointer switching  |

---

# ðŸ“Œ Trees

| Problem                  | Time     | Space    | Notes             |
| ------------------------ | -------- | -------- | ----------------- |
| Max Depth of Binary Tree | **O(n)** | **O(h)** | `h` = height      |
| Validate BST             | **O(n)** | **O(h)** | Inorder traversal |
| Symmetric Tree           | **O(n)** | **O(h)** | DFS               |
| Level Order Traversal    | **O(n)** | **O(n)** | Queue (BFS)       |
| Lowest Common Ancestor   | **O(n)** | **O(h)** | Postorder DFS     |

---

# ðŸ“Œ Graphs

| Problem            | Time           | Space      | Notes                 |
| ------------------ | -------------- | ---------- | --------------------- |
| Number of Islands  | **O(mÂ·n)**     | **O(mÂ·n)** | DFS/BFS               |
| Course Schedule    | **O(V + E)**   | **O(V)**   | Topological sort      |
| Word Ladder        | **O(nÂ·kÂ²)**    | **O(n)**   | BFS + transformations |
| Clone Graph        | **O(V + E)**   | **O(V)**   | HashMap               |
| Network Delay Time | **O(E log V)** | **O(V)**   | Dijkstra              |

---

# ðŸ“Œ Searching & Sorting

| Problem              | Time               | Space        | Notes                  |
| -------------------- | ------------------ | ------------ | ---------------------- |
| Merge Sort           | **O(n log n)**     | **O(n)**     | Stable                 |
| Quick Sort           | **O(n log n)** avg | **O(log n)** | Worst: O(nÂ²)           |
| Binary Search        | **O(log n)**       | **O(1)**     | Iterative              |
| Search Rotated Array | **O(log n)**       | **O(1)**     | Modified binary search |
| First Bad Version    | **O(log n)**       | **O(1)**     | Binary search          |

---

# ðŸ“Œ Dynamic Programming

| Problem                        | Time            | Space         | Notes              |
| ------------------------------ | --------------- | ------------- | ------------------ |
| Fibonacci                      | **O(n)**        | **O(1)**      | Iterative          |
| Climbing Stairs                | **O(n)**        | **O(1)**      | DP                 |
| Longest Increasing Subsequence | **O(n log n)**  | **O(n)**      | Binary search      |
| Maximum Subarray               | **O(n)**        | **O(1)**      | Kadane             |
| Coin Change                    | **O(nÂ·amount)** | **O(amount)** | Unbounded knapsack |

---

# ðŸŽ¯ Interview Gold Rules (Memorize This)

* **Array + HashMap â†’ O(n)**
* **Binary Search â†’ O(log n)**
* **Tree DFS â†’ O(n), Space = O(height)**
* **Graph â†’ O(V + E)**
* **DP â†’ Depends on states Ã— transitions**

---

If you want next:

* âœ… **One-line explanation for each complexity (interview script)**
* âœ… **Java code + complexity justification**
* âœ… **Trick questions interviewers ask on complexity**

Just tell me ðŸ‘‡
